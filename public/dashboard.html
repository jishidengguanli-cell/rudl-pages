<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>控制台 - RU Download</title>
<style>
  body{margin:0;background:#0f172a;color:#e5e7eb;font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  header{background:#0b1222;border-bottom:1px solid #1f2937}
  .wrap{max-width:980px;margin:0 auto;padding:16px}
  nav{display:flex;align-items:center;gap:12px}
  nav .right{margin-left:auto;display:flex;gap:10px}
  a{color:#93c5fd;text-decoration:none}
  .btn{padding:8px 12px;border-radius:10px;border:0;background:#3b82f6;color:#fff;cursor:pointer}
  .btn.red{background:#ef4444}
  .card{background:#111827;border:1px solid #1f2937;border-radius:16px;padding:24px;margin-top:20px}
  .muted{color:#9ca3af}
  table{width:100%;border-collapse:collapse;margin-top:12px}
  th,td{border-bottom:1px solid #1f2937;padding:10px;text-align:left}
  th{color:#9ca3af;font-weight:600}
  .tag{display:inline-block;padding:2px 8px;border-radius:999px;background:#0b1222;border:1px solid #334155;color:#e5e7eb;font-size:12px}
  .right-ctrls{display:flex;gap:8px}
  /* Modal */
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.5);z-index:50}
  .modal .panel{width:min(680px,92vw);background:#111827;border:1px solid #1f2937;border-radius:16px;padding:20px}
  label{display:block;margin:10px 0 4px;color:#9ca3af}
  input[type="text"],input[type="file"]{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #334155;background:#0b1222;color:#e5e7eb}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .actions{display:flex;gap:10px;justify-content:flex-end;margin-top:16px}
  .bar{height:6px;background:#0b1222;border:1px solid #334155;border-radius:999px;overflow:hidden}
  .bar>i{display:block;height:100%;width:0;background:#3b82f6}
  .small{font-size:12px;color:#9ca3af}
  .copy{margin-left:8px;padding:4px 8px;background:#374151;border:1px solid #4b5563;border-radius:8px;color:#e5e7eb;cursor:pointer;font-size:12px}
</style>

<header>
  <div class="wrap">
    <nav>
      <strong>控制台</strong>
      <div class="right">
        <a href="/dashboard.html">分發列表</a>
        <a href="#" id="logout">登出</a>
      </div>
    </nav>
  </div>
</header>

<main class="wrap">
  <div class="card">
    <div style="display:flex;align-items:center;gap:12px;justify-content:space-between">
      <div>
        <h2 style="margin:0 0 6px">分發列表</h2>
        <div id="me" class="muted">讀取中…</div>
      </div>
      <div class="right-ctrls">
        <button class="btn" id="btn-new">➕ 新增分發</button>
      </div>
    </div>

    <div id="empty" class="muted" style="margin-top:14px;display:none">目前沒有分發，按右上「新增分發」開始。</div>
    <table id="tbl" style="display:none">
      <thead>
        <tr>
          <th>短碼</th><th>標題</th><th>版本</th><th>檔案</th><th>建立時間</th><th>下載頁</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>
</main>

<!-- 新增分發 Modal -->
<div class="modal" id="modal">
  <div class="panel">
    <h3 style="margin:0 0 8px">新增分發</h3>
    <p class="small">上傳 APK 或 IPA（可擇一或兩者都上傳）。上傳完成後會建立一個短碼。</p>
    <div class="row">
      <div>
        <label>標題（顯示用，可選）</label>
        <input id="title" type="text" placeholder="例如：My App" />
      </div>
      <div>
        <label>版本（顯示用，可選）</label>
        <input id="version" type="text" placeholder="例如：1.0.0（僅顯示，不影響 iOS 安裝）" />
      </div>
    </div>
    <label>Bundle ID（顯示用，可選）</label>
    <input id="bundle" type="text" placeholder="例如：com.example.app（僅顯示，不影響 iOS 安裝）" />
    <div class="row" style="margin-top:8px">
      <div>
        <label>APK 檔（android）</label>
        <input id="apk" type="file" accept=".apk" />
        <div class="bar" style="margin-top:8px"><i id="p-apk"></i></div>
        <div class="small" id="t-apk"></div>
      </div>
      <div>
        <label>IPA 檔（iOS）</label>
        <input id="ipa" type="file" accept=".ipa" />
        <div class="bar" style="margin-top:8px"><i id="p-ipa"></i></div>
        <div class="small" id="t-ipa"></div>
      </div>
    </div>
    <div class="actions">
      <button class="btn red" id="btn-cancel">取消</button>
      <button class="btn" id="btn-create">上傳並建立</button>
    </div>
    <div class="small" id="err" style="color:#fca5a5;margin-top:6px;min-height:18px"></div>
  </div>
</div>

<script>
// ===== 登入保護 & 初始載入 =====
(async () => {
  const meEl = document.getElementById("me");
  try {
    const r = await fetch("/api/auth/me", { credentials: "include" });
    const txt = await r.text();
    let me;
    try { me = JSON.parse(txt); }
    catch { throw new Error("/api/auth/me 非 JSON，回傳： " + txt.slice(0, 160)); }

    if (!r.ok || !me?.authenticated) {
      location.href = "/login.html?next=/dashboard.html";
      return;
    }
    meEl.textContent = `目前登入：${me.email}`;
    await loadList();
  } catch (err) {
    meEl.textContent = "載入失敗：" + (err?.message || err);
  }
})();

// 登出
document.getElementById("logout").addEventListener("click", async (e) => {
  e.preventDefault();
  try { await fetch("/api/auth/logout", { method:"POST", credentials:"include" }); } catch {}
  location.href = "/login.html";
});

// ===== 分發列表 =====
async function loadList() {
  const tbl = document.getElementById("tbl");
  const tbody = document.getElementById("tbody");
  const empty = document.getElementById("empty");
  tbody.innerHTML = "";

  try {
    const r = await fetch("/api/links/list", { credentials: "include" });
    const txt = await r.text();
    let data;
    try { data = JSON.parse(txt); }
    catch { throw new Error("/api/links/list 非 JSON，回傳： " + txt.slice(0, 160)); }

    if (!r.ok) throw new Error(data?.error || "讀取清單失敗");

    const items = Array.isArray(data.items) ? data.items : [];
    if (!items.length) {
      tbl.style.display = "none";
      empty.style.display = "block";
      empty.textContent = "目前沒有分發，按右上「新增分發」開始。";
      return;
    }
    empty.style.display = "none";
    tbl.style.display = "table";

    for (const it of items) {
      const hasApk = !!it.apk_key, hasIpa = !!it.ipa_key;
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><code>${it.code}</code></td>
        <td>${esc(it.title||"")}</td>
        <td>${esc(it.version||"")}</td>
        <td>
          ${hasApk?'<span class="tag">APK</span>':''}
          ${hasIpa?'<span class="tag">IPA</span>':''}
        </td>
        <td>${fmt(it.createdAt)}</td>
        <td>
          <div class="small">
            <a href="/d/${it.code}" target="_blank">${absLink(it.code)}</a>
            <button class="copy" data-url="${absLink(it.code)}">複製</button>
          </div>
        </td>`;
      tbody.appendChild(tr);
    }
  } catch (err) {
    tbl.style.display = "none";
    empty.style.display = "block";
    empty.textContent = "讀取失敗：" + (err?.message || err);
  }
}

function esc(s){return String(s).replace(/[&<>"]/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"}[m]))}
function fmt(ts){if(!ts)return ""; const d=new Date(ts); return `${d.getFullYear()}-${(d.getMonth()+1+"").padStart(2,"0")}-${(d.getDate()+"").padStart(2,"0")} ${d.toTimeString().slice(0,8)}`;}
function absLink(code){ return `${location.origin}/d/${code}`; }

// 一鍵複製（事件委派）
document.addEventListener('click', async (ev) => {
  const btn = ev.target && ev.target.closest ? ev.target.closest('.copy') : null;
  if (!btn) return;
  const url = btn.getAttribute('data-url');
  try {
    await navigator.clipboard.writeText(url);
    const old = btn.textContent;
    btn.textContent = '已複製';
    btn.disabled = true;
    setTimeout(()=>{ btn.textContent = old; btn.disabled = false; }, 1200);
  } catch {
    alert('無法自動複製，請手動複製：\n' + url);
  }
});

// ===== 新增分發（Modal + 上傳 + 解析 IPA） =====
const modal = document.getElementById("modal");
document.getElementById("btn-new").addEventListener("click", ()=>{ modal.style.display="flex"; resetModal(); });
document.getElementById("btn-cancel").addEventListener("click", ()=>{ modal.style.display="none"; });

function resetModal(){
  $("title").value = ""; $("version").value = ""; $("bundle").value = "";
  $("apk").value = ""; $("ipa").value = "";
  $("p-apk").style.width = "0%"; $("p-ipa").style.width = "0%";
  $("t-apk").textContent = ""; $("t-ipa").textContent = "";
  $("err").textContent = "";
}

document.getElementById("btn-create").addEventListener("click", async ()=>{
  const title = $("title").value.trim();
  const version = $("version").value.trim();   // 顯示用
  const bundle = $("bundle").value.trim();     // 顯示用
  const apkFile = $("apk").files[0];
  const ipaFile = $("ipa").files[0];
  const err = $("err"); err.textContent = "";

  if (!apkFile && !ipaFile) { err.textContent = "請至少選擇一個檔案（APK 或 IPA）。"; return; }

  // 先嘗試從本地解析 IPA 的 bundleId/version（失敗就算了，不擋流程）
  let ipaMeta = null;
  if (ipaFile) {
    try {
      $("t-ipa").textContent = "解析 IPA 中…";
      const meta = await inspectIpa(ipaFile); // {bundle_id, version}
      if (meta?.bundle_id || meta?.version) ipaMeta = meta;
      $("t-ipa").textContent = "解析完成";
    } catch (e) {
      $("t-ipa").textContent = "解析失敗（將以顯示資料為準）";
    }
  }

  // 逐一上傳（APK -> IPA）
  let apkKey = "", ipaKey = "";
  try {
    if (apkFile) {
      $("t-apk").textContent = "初始化上傳…";
      apkKey = await uploadFile(apkFile, "android", $("p-apk"), p => $("t-apk").textContent = p);
    }
    if (ipaFile) {
      $("t-ipa").textContent = "初始化上傳…";
      ipaKey = await uploadFile(ipaFile, "ios", $("p-ipa"), p => $("t-ipa").textContent = p);
    }
  } catch(e){ err.textContent = "上傳失敗：" + (e?.message || e); return; }

  // 建立分發（顯示欄位 + 檔案 key + ipaMeta）
  try {
    const r = await fetch("/api/links/create", {
      method: "POST",
      credentials: "include",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ title, version, bundle_id: bundle, apkKey, ipaKey, ipaMeta })
    });
    const data = await r.json();
    if (!r.ok) { throw new Error(data?.error || "建立分發失敗"); }
    modal.style.display = "none";
    await loadList();
  } catch(e){ err.textContent = String(e); }
});

// 呼叫 /api/upload/init 取得預簽名 URL，並用 XHR PUT 上傳（可顯示進度）
async function uploadFile(file, folder, barEl, setText){
  setText("請求預簽名 URL…");
  const init = await fetch("/api/upload/init", {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      filename: file.name,
      folder,
      contentType: file.type || (folder==="android" ? "application/vnd.android.package-archive" : "application/octet-stream")
    })
  }).then(r => r.json());
  if (!init?.uploadUrl || !init?.key) throw new Error("取得預簽名 URL 失敗");

  setText("上傳中… 0%");
  await xhrPut(init.uploadUrl, file, init.contentType, (pct) => {
    barEl.style.width = pct + "%";
    setText("上傳中… " + pct + "%");
  });
  setText("完成");
  return init.key; // 回傳 R2 key
}

function xhrPut(url, file, contentType, onProgress){
  return new Promise((resolve, reject)=>{
    const xhr = new XMLHttpRequest();
    xhr.open("PUT", url, true);
    if (contentType) xhr.setRequestHeader("Content-Type", contentType);
    xhr.upload.onprogress = (e)=>{ if (e.lengthComputable && onProgress) onProgress(Math.round(e.loaded*100/e.total)); };
    xhr.onload = ()=>{ (xhr.status>=200 && xhr.status<300) ? resolve(null) : reject(new Error("HTTP "+xhr.status+" "+xhr.responseText)); };
    xhr.onerror = ()=> reject(new Error("Network error"));
    xhr.send(file);
  });
}

function $(id){ return document.getElementById(id); }

// 解析 IPA：讀 ZIP 的中央目錄找 Payload/*.app/Info.plist，支援 deflate 與未壓縮。
// Info.plist 若是 XML 直接解析；若是 binary plist（bplist00），使用簡易解析器取字串與字典。
async function inspectIpa(file) {
  const buf = await file.arrayBuffer();
  const view = new DataView(buf);

  // 1) 找 EOCD（End of Central Directory），從檔尾往回 64KB 搜尋
  const eocdSig = 0x06054b50;
  const maxBack = Math.min(65557, buf.byteLength);
  let eocd = -1;
  for (let i = buf.byteLength - 22; i >= buf.byteLength - maxBack; i--) {
    if (view.getUint32(i, true) === eocdSig) { eocd = i; break; }
  }
  if (eocd < 0) throw new Error("ZIP EOCD not found");
  const cdCount = view.getUint16(eocd + 10, true);
  const cdSize  = view.getUint32(eocd + 12, true);
  const cdOff   = view.getUint32(eocd + 16, true);

  // 2) 走訪 Central Directory 找 Info.plist 的 entry
  const cdView = new DataView(buf, cdOff, cdSize);
  let off = 0, entry = null;
  for (let i = 0; i < cdCount; i++) {
    const sig = cdView.getUint32(off, true); if (sig !== 0x02014b50) break;
    const compMethod = cdView.getUint16(off + 10, true);
    const compSize   = cdView.getUint32(off + 20, true);
    const nameLen    = cdView.getUint16(off + 28, true);
    const extraLen   = cdView.getUint16(off + 30, true);
    const commLen    = cdView.getUint16(off + 32, true);
    const localOff   = cdView.getUint32(off + 42, true);
    const nameBytes  = new Uint8Array(buf, cdOff + off + 46, nameLen);
    const name       = new TextDecoder().decode(nameBytes);

    if (/^Payload\/[^/]+\.app\/Info\.plist$/i.test(name)) {
      entry = { compMethod, compSize, localOff, name };
      break;
    }
    off += 46 + nameLen + extraLen + commLen;
  }
  if (!entry) throw new Error("Info.plist not found");

  // 3) 讀 Local File Header 找到檔案資料起點
  const lfh = new DataView(buf, entry.localOff, 30);
  if (lfh.getUint32(0, true) !== 0x04034b50) throw new Error("LFH signature mismatch");
  const nameLen = lfh.getUint16(26, true);
  const extraLen = lfh.getUint16(28, true);
  const dataStart = entry.localOff + 30 + nameLen + extraLen;
  const compData = new Uint8Array(buf, dataStart, entry.compSize);

  // 4) 解壓（method 0=store, 8=deflate）
  let plistBytes;
  if (entry.compMethod === 0) {
    plistBytes = compData;
  } else if (entry.compMethod === 8) {
    if (typeof DecompressionStream !== "undefined") {
      const ds = new DecompressionStream("deflate-raw");
      const decompressed = await new Response(new Blob([compData]).stream().pipeThrough(ds)).arrayBuffer();
      plistBytes = new Uint8Array(decompressed);
    } else {
      throw new Error("Deflate not supported in this browser");
    }
  } else {
    throw new Error("Unsupported ZIP compression method: " + entry.compMethod);
  }

  // 5) 解析 plist（XML or binary）
  if (plistBytes[0] === 0x3c) { // '<' -> XML
    const text = new TextDecoder().decode(plistBytes);
    return parsePlistXML(text);
  }
  const head = new TextDecoder().decode(plistBytes.slice(0, 8));
  if (head.startsWith("bplist0")) {
    const obj = parseBinaryPlist(plistBytes.buffer);
    return {
      bundle_id: String(obj["CFBundleIdentifier"] || ""),
      version:   String(obj["CFBundleShortVersionString"] || obj["CFBundleVersion"] || "")
    };
  }
  throw new Error("Unknown plist format");
}

function parsePlistXML(xml) {
  const doc = new DOMParser().parseFromString(xml, "application/xml");
  const dicts = doc.getElementsByTagName("dict");
  if (!dicts.length) return { bundle_id:"", version:"" };
  const dict = dicts[0];
  const kids = Array.from(dict.children);
  const map = {};
  for (let i = 0; i < kids.length - 1; i++) {
    if (kids[i].tagName === "key") {
      const k = kids[i].textContent || "";
      const vNode = kids[i+1];
      const v = vNode ? (vNode.textContent || "") : "";
      map[k] = v;
    }
  }
  return {
    bundle_id: String(map["CFBundleIdentifier"] || ""),
    version:   String(map["CFBundleShortVersionString"] || map["CFBundleVersion"] || "")
  };
}

// 最小版 binary plist 解析器（足夠拿兩個欄位）
function parseBinaryPlist(buf) {
  const dv = new DataView(buf);
  const u8 = new Uint8Array(buf);
  const head = new TextDecoder().decode(u8.subarray(0, 8));
  if (!head.startsWith("bplist0")) throw new Error("not bplist");

  // 讀 trailer
  const trailer = new DataView(buf, u8.length - 32, 32);
  const offsetSize = trailer.getUint8(6);
  const objRefSize = trailer.getUint8(7);
  const numObjects = Number(readUIntBE(trailer, 8, 8));
  const topObject  = Number(readUIntBE(trailer, 16, 8));
  const offsetTbl  = Number(readUIntBE(trailer, 24, 8));

  // 讀 offsets
  const offsets = [];
  for (let i = 0; i < numObjects; i++) offsets.push(Number(readUIntBE(dv, offsetTbl + i*offsetSize, offsetSize)));

  function readObj(idx) {
    const off = offsets[idx];
    const t = u8[off];
    const type = (t & 0xF0) >> 4;
    const info = (t & 0x0F);

    if (type === 0x0) { // null/bool
      if (info === 0x8) return false;
      if (info === 0x9) return true;
      return null;
    }
    if (type === 0x1) { // integer
      const len = 1 << info;
      return Number(readUIntBE(dv, off+1, len));
    }
    if (type === 0x2) { // real
      const len = 1 << info;
      if (len === 4) return dv.getFloat32(off+1, false);
      if (len === 8) return dv.getFloat64(off+1, false);
      return null;
    }
    if (type === 0x4) { // data
      const {len, pos} = readLen(off, info);
      return u8.slice(pos, pos+len);
    }
    if (type === 0x5) { // ascii string
      const {len, pos} = readLen(off, info);
      return new TextDecoder().decode(u8.subarray(pos, pos+len));
    }
    if (type === 0x6) { // utf-16-be string
      const {len, pos} = readLen(off, info);
      let s=""; for (let i=0;i<len;i++){ s += String.fromCharCode(dv.getUint16(pos+i*2, false)); }
      return s;
    }
    if (type === 0xA) { // array
      const {len, pos} = readLen(off, info);
      const arr = [];
      for (let i=0;i<len;i++){
        const objRef = Number(readUIntBE(dv, pos + i*objRefSize, objRefSize));
        arr.push(readObj(objRef));
      }
      return arr;
    }
    if (type === 0xD) { // dict
      const {len, pos} = readLen(off, info);
      const keys = []; const vals = [];
      for (let i=0;i<len;i++){
        const keyRef = Number(readUIntBE(dv, pos + i*objRefSize, objRefSize));
        keys.push(readObj(keyRef));
      }
      const vs = pos + len*objRefSize;
      for (let i=0;i<len;i++){
        const valRef = Number(readUIntBE(dv, vs + i*objRefSize, objRefSize));
        vals.push(readObj(valRef));
      }
      const o:any = {}; for (let i=0;i<len;i++) o[String(keys[i])] = vals[i];
      return o;
    }
    return null;
  }

  function readLen(off, info){
    if (info !== 0x0F) return { len: info, pos: off+1 };
    // 長度是下一個「整數物件」
    const t = u8[off+1];
    const type = (t & 0xF0) >> 4;
    const info2 = (t & 0x0F);
    if (type !== 0x1) throw new Error("bplist len not int");
    const len = 1 << info2;
    const val = Number(readUIntBE(dv, off+2, len));
    return { len: val, pos: off+2+len };
  }

  function readUIntBE(dv, off, len){
    let n = 0n; for (let i=0;i<len;i++){ n = (n<<8n) | BigInt(dv.getUint8(off+i)); }
    return n;
  }

  const root = readObj(topObject);
  return root || {};
}
</script>
